{"version":3,"file":"index.js","sources":["../src/Box.ts","../src/QuadTree.ts","../src/Circle.ts","../src/Point.ts"],"sourcesContent":["/**\n * Box class.\n * @class Box\n */\nimport {Point} from \"./Point\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Box implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly w: number;\n    readonly h: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Box constructor;\n     * @constructs Box\n     * @param {number} x - X coordinate of the box.\n     * @param {number} y - Y coordinate of the box.\n     * @param {number} w - Width of the box.\n     * @param {number} h - Height of the box.\n     * @param {*} [data] - Data to store along the box.\n     */\n    constructor(x: number, y: number, w: number, h: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        this.data = data;\n    }\n\n    /**\n     * Check if a point is contained in the box.\n     * @param {Point|Object} point - The point to test if it is contained in the box.\n     * @returns {boolean} - True if the point is contained in the box, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return point.x >= this.x &&\n            point.x <= this.x + this.w &&\n            point.y >= this.y &&\n            point.y <= this.y + this.h;\n    }\n\n    /**\n     * Check if a box intersects with this box.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        return !(range.x > this.x + this.w\n            || range.x + range.w < this.x\n            || range.y > this.y + this.h\n            || range.y + range.h < this.y);\n    }\n\n}\n","import {Box, Point} from './index';\nimport {QuadTreeConfig, QuadTreeConfigComplete, Tree, Shape} from \"./types\";\n\nconst defaultConfig: QuadTreeConfigComplete = {\n    capacity: 4,\n    removeEmptyNodes: false,\n    maximumDepth: -1,\n    arePointsEqual: (point1: Point, point2: Point) => point1.x === point2.x && point1.y === point2.y\n};\n\n/**\n * QuadTree class.\n * @class QuadTree\n */\nexport class QuadTree {\n    private readonly container: Box;\n    private isDivided: boolean;\n    private points: Point[];\n    private readonly config: QuadTreeConfigComplete;\n    private ne!: QuadTree;\n    private nw!: QuadTree;\n    private se!: QuadTree;\n    private sw!: QuadTree;\n\n    /**\n     * Create a new QuadTree\n     * @constructor\n     * @param {Box} container - The box on which the QuadTree will operate.\n     * @param {Object} [config] - The configuration of the quadtree.\n     * @param {number} [config.capacity] - The maximum amount of points per node.\n     * @param {boolean} [config.removeEmptyNodes] - Specify if the quadtree has to remove subnodes if they are empty.\n     * @param {number} [config.maximumDepth] - Specify the maximum depth of the tree.\n     * @param {function} [config.arePointsEqual] - Specify a custom method to compare point for removal.\n     * @param {(Object[]|Point[])} [points] - An array of initial points to insert in the QuadTree.\n     * @param {number} points[].x - X coordinate of the point.\n     * @param {number} points[].y - Y coordinate of the point.\n     */\n    constructor(container: Box, config?: QuadTreeConfig, points: Point[] = []) {\n        this.container = container;\n        this.config = Object.assign({}, defaultConfig, config);\n\n        this.isDivided = false;\n        this.points = [];\n\n        for (const point of points) {\n            this.insertRecursive(point);\n        }\n    }\n\n    /**\n     * Return a tree representation of the QuadTree\n     * @returns {{se: *, sw: *, ne: *, nw: *}|Number} - A tree representation of the QuadTree\n     */\n    getTree(): Tree {\n        let tree;\n\n        if (this.isDivided) {\n            tree = {\n                ne: this.ne.getTree(),\n                nw: this.nw.getTree(),\n                se: this.se.getTree(),\n                sw: this.sw.getTree()\n            };\n\n        } else {\n            tree = this.getNodePointAmount();\n        }\n\n        return tree;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @returns {(Object[]|Point[])} - An array containing all the points.\n     */\n    getAllPoints(): Point[] {\n        const pointsList: Point[] = [];\n        this.getAllPointsRecursive(pointsList);\n        return pointsList;\n    }\n\n    /**\n     * Get all the points in the QuadTree\n     * @param {(Object[]|Point[])} pointsList\n     * @private\n     */\n    private getAllPointsRecursive(pointsList: Point[]): void {\n        if (!this.isDivided) {\n            Array.prototype.push.apply(pointsList, this.points.slice());\n            return;\n        }\n\n        this.ne.getAllPointsRecursive(pointsList);\n        this.nw.getAllPointsRecursive(pointsList);\n        this.se.getAllPointsRecursive(pointsList);\n        this.sw.getAllPointsRecursive(pointsList);\n    }\n\n    /**\n     * Return the amount of points in this node.\n     * @returns {number} - The amount of points in this node.\n     * @private\n     */\n    private getNodePointAmount(): number {\n        return this.points.length;\n    }\n\n    /**\n     * Divide this node into 4 sub-nodes\n     * @private\n     */\n    private divide(): void {\n        const childMaximumDepth = this.config.maximumDepth === -1 ? -1 : this.config.maximumDepth - 1;\n        const childConfig = Object.assign({}, this.config, {maximumDepth: childMaximumDepth});\n\n        this.isDivided = true;\n\n        const x = this.container.x;\n        const y = this.container.y;\n        const w = this.container.w / 2;\n        const h = this.container.h / 2;\n\n        // Creation of the sub-nodes, and insertion of the current point\n        this.ne = new QuadTree(new Box(x + w, y, w, h), childConfig, this.points.slice());\n        this.nw = new QuadTree(new Box(x, y, w, h), childConfig, this.points.slice());\n        this.se = new QuadTree(new Box(x + w, y + h, w, h), childConfig, this.points.slice());\n        this.sw = new QuadTree(new Box(x, y + h, w, h), childConfig, this.points.slice());\n\n        // We empty this node points\n        this.points.length = 0;\n        this.points = [];\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to remove\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     */\n    remove(pointOrArray: Point | Point[]): void {\n        if (Array.isArray(pointOrArray)) {\n            for (const point of pointOrArray) {\n                this.removeRecursive(point);\n            }\n        } else {\n            this.removeRecursive(pointOrArray);\n        }\n    }\n\n    /**\n     * Remove a point in the QuadTree\n     * @param {(Point|Object)} point - A point to remove\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @private\n     */\n    private removeRecursive(point: Point): void {\n        if (!this.container.contains(point)) {\n            return;\n        }\n\n        if (!this.isDivided) {\n            const len = this.points.length;\n            for (let i = len - 1; i >= 0; i--) {\n                if (this.config.arePointsEqual(point, this.points[i])) {\n                    this.points.splice(i, 1);\n                }\n            }\n\n            return;\n        }\n\n        this.ne.removeRecursive(point);\n        this.nw.removeRecursive(point);\n        this.se.removeRecursive(point);\n        this.sw.removeRecursive(point);\n\n        if (this.config.removeEmptyNodes) {\n            if (this.ne.getNodePointAmount() === 0 && !this.ne.isDivided &&\n                this.nw.getNodePointAmount() === 0 && !this.nw.isDivided &&\n                this.se.getNodePointAmount() === 0 && !this.se.isDivided &&\n                this.sw.getNodePointAmount() === 0 && !this.sw.isDivided) {\n\n                this.isDivided = false;\n\n                delete this.ne;\n                delete this.nw;\n                delete this.se;\n                delete this.sw;\n            }\n        }\n    }\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object|Point[]|Object[])} pointOrArray - A point or an array of points to insert\n     * @param {number} pointOrArray.x - X coordinate of the point\n     * @param {number} pointOrArray.y - Y coordinate of the point\n     * @returns {boolean} true if the point or all the point has been inserted, false otherwise\n     */\n    insert(pointOrArray: Point | Point[]): boolean {\n        if (Array.isArray(pointOrArray)) {\n            let returnValue = true;\n            for (const point of pointOrArray) {\n                returnValue = returnValue && this.insertRecursive(point);\n            }\n            return returnValue;\n        } else {\n            return this.insertRecursive(pointOrArray);\n        }\n    }\n\n\n    /**\n     * Insert a point in the QuadTree\n     * @param {(Point|Object)} point - A point to insert\n     * @param {number} point.x - X coordinate of the point\n     * @param {number} point.y - Y coordinate of the point\n     * @returns {boolean}\n     * @private\n     */\n    private insertRecursive(point: Point): boolean {\n        if (!this.container.contains(point)) {\n            return false;\n        }\n        if (!this.isDivided) {\n            if (this.getNodePointAmount() < this.config.capacity || this.config.maximumDepth === 0) {\n                this.points.push(point);\n                return true;\n            } else if (this.config.maximumDepth === -1 || this.config.maximumDepth > 0) {\n                this.divide();\n            }\n\n        }\n\n        if (this.isDivided) {\n            if (this.ne.insertRecursive(point)) return true;\n            if (this.nw.insertRecursive(point)) return true;\n            if (this.se.insertRecursive(point)) return true;\n            return this.sw.insertRecursive(point);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Query all the point within a range\n     * @param {Shape} range - The range to test\n     * @returns {(Point[]|Object[])} - The points within the range\n     */\n    query(range: Shape): Point[] {\n        const pointsFound: Point[] = [];\n        this.queryRecursive(range, pointsFound);\n        return pointsFound;\n    }\n\n    /**\n     * @param {Shape} range\n     * @param {(Point[]|Object[])} pointsFound\n     * @returns {(Point[]|Object[])}\n     * @private\n     */\n    private queryRecursive(range: Shape, pointsFound: Point[]): void {\n        if (range.intersects(this.container)) {\n            if (this.isDivided) {\n                this.ne.queryRecursive(range, pointsFound);\n                this.nw.queryRecursive(range, pointsFound);\n                this.se.queryRecursive(range, pointsFound);\n                this.sw.queryRecursive(range, pointsFound);\n            } else {\n                const p = this.points.filter((point) => range.contains(point));\n\n                Array.prototype.push.apply(pointsFound, p);\n            }\n        }\n    }\n\n    /**\n     * Clear the QuadTree\n     */\n    clear(): void {\n        this.points = [];\n        this.isDivided = false;\n\n        delete this.ne;\n        delete this.nw;\n        delete this.se;\n        delete this.sw;\n    }\n}\n\n\n","/**\n * Box Circle.\n * @class Circle\n */\nimport {Point} from \"./Point\";\nimport {Box} from \"./Box\";\nimport {Shape, UserCustomData} from \"./types\";\n\nexport class Circle  implements Shape{\n    readonly x: number;\n    readonly y: number;\n    readonly r: number;\n    readonly rPow2: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Circle constructor;\n     * @constructs Circle\n     * @param {number} x - X coordinate of the circle.\n     * @param {number} y - Y coordinate of the circle.\n     * @param {number} r - Radius of the circle.\n     * @param {*} [data] - Data to store along the circle.\n     */\n    constructor(x: number, y: number, r: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n        this.rPow2 = this.r * this.r; // To avoid square roots\n        this.data = data;\n    }\n\n    private euclideanDistancePow2(point1: Point, point2: Point): number {\n        return Math.pow((point1.x - point2.x), 2) + Math.pow((point1.y - point2.y), 2);\n    }\n\n    /**\n     * Check if a point is contained in the circle.\n     * @param {Point|Object} point - The point to test if it is contained in the circle.\n     * @returns {boolean} - True if the point is contained in the circle, otherwise false.\n     */\n    contains(point: Point): boolean {\n        return this.euclideanDistancePow2(point, this) <= this.rPow2;\n    }\n\n    /**\n     * Check if a box intersects with this circle.\n     * @param {Box|Object} range - The box to test the intersection with.\n     * @returns {boolean} - True if it intersects, otherwise false.\n     */\n    intersects(range: Box): boolean {\n        const dX = this.x - Math.max(range.x, Math.min(this.x, range.x + range.w));\n        const dY = this.y - Math.max(range.y, Math.min(this.y, range.y + range.h));\n        return (dX * dX + dY * dY) <= (this.rPow2);\n    }\n}\n","/**\n * Point class.\n * @class Point\n */\nimport {UserCustomData} from \"./types\";\n\nexport class Point {\n    readonly x: number;\n    readonly y: number;\n    readonly data: UserCustomData;\n\n    /**\n     * Point constructor.\n     * @constructs Point\n     * @param {number} x - X coordinate of the point.\n     * @param {number} y - Y coordinate of the point.\n     * @param {*} [data] - Data to store along the point.\n     */\n    constructor(x: number, y: number, data?: UserCustomData) {\n        this.x = x;\n        this.y = y;\n        this.data = data;\n    }\n\n}"],"names":["Box","[object Object]","x","y","w","h","data","this","point","range","defaultConfig","capacity","removeEmptyNodes","maximumDepth","arePointsEqual","point1","point2","QuadTree","container","config","points","Object","assign","isDivided","insertRecursive","tree","ne","getTree","nw","se","sw","getNodePointAmount","pointsList","getAllPointsRecursive","Array","prototype","push","apply","slice","length","childMaximumDepth","childConfig","pointOrArray","isArray","removeRecursive","contains","i","splice","returnValue","divide","pointsFound","queryRecursive","intersects","p","filter","r","rPow2","Math","pow","euclideanDistancePow2","dX","max","min","dY"],"mappings":"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"}